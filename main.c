#include "pbPlots.h"
#include "supportLib.h"
#include <math.h>
#include <stdio.h>
#include "functions.h"

int main(){
    // </>
    //
    // User Information Gathering
    //
    // </>
    struct fun1g function1g;
    struct fun2g function2g;
    struct fun_exp function_exp;


    printf("\n\n< Graph Generator TUI >\n\n");
    printf("'1' for f(x) = ax + b\n");
    printf("'2' for f(x) = ax^2 + bx + b\n");
    printf("'3' for f(x) = a^x\n\n:");
    int choice;
    scanf("%d", &choice);
    double fun_a;
    double fun_b;
    double fun_c;

    if(choice == 1) // choosed 1st degree
    {
        printf("\n\n< f(x) = ax + b > \n\n");
        printf("'a' value: ");
        scanf("%lf", &fun_a);
        printf("\n'b' value: ");
        scanf("%lf", &fun_b);

        function1g.a = fun_a;
        function1g.b = fun_b;
        
    }

    else if(choice == 2)
    {
        printf("\n\n< f(x) = ax^2 + bx + c > \n\n");
        printf("'a' value: ");
        scanf("%lf", &fun_a);
        printf("\n'b' value: ");
        scanf("%lf", &fun_b);
        printf("\n'c' value: ");
        scanf("%lf", &fun_c);

        function2g.a = fun_a;
        function2g.b = fun_b;
        function2g.c = fun_c;
    }

    else if(choice == 3)
    {
        printf("\n\n< f(x) = a^x >\n\n");
        printf("'a' value: ");
        scanf("%lf", &fun_a);

        function_exp.a = fun_a;
    }
    // choosed 2nd degree
    // </>
    //
    // PROCESSING AND CREATING IMAGE:
    //
    // </>
    
    // setting X and Y values.
    double x[200];
    double y[200];

    // looping to function
    double range_final = 10;
    double variable_initial_index = -10;
    double accuracy = 1;
    int list_index = 0;

    if(choice == 1){
        for (; variable_initial_index < range_final; variable_initial_index += accuracy){
        x[list_index] = variable_initial_index;              
        y[list_index] = fun1g(function1g.a, function1g.b, variable_initial_index);
        list_index++; 
        }
    }

    else if(choice == 2){
        for (; variable_initial_index < range_final; variable_initial_index += accuracy){
        x[list_index] = variable_initial_index;
        y[list_index] = fun2g(function2g.a, function2g.b, function2g.c, variable_initial_index);
        list_index++; 
        }
    }

    else if(choice == 3){
        for (; variable_initial_index < range_final; variable_initial_index += accuracy){
        x[list_index] = variable_initial_index;
        y[list_index] = fun_exp(function_exp.a, variable_initial_index);
        list_index++; 
        }
    }

    // pbPlots:

    // Line:
    ScatterPlotSeries *line = GetDefaultScatterPlotSeriesSettings();

    // Line details and settings:
    line->xs = x;
    line->ys = y;
    line->xsLength = list_index;
    line->ysLength = list_index;
    line->linearInterpolation = true;

    // Background:
    ScatterPlotSettings *background = GetDefaultScatterPlotSettings();

    // Background settings and details
    background->autoPadding = true;
    background->yAxisAuto = true;
    background->autoBoundaries = true;
    background->showGrid =  true;
    background->xAxisBottom = true;
    background->height = 1200;
    background->width = 2800;
    background->title = L"Generated by Marco's software.";
    background->titleLength = wcslen(background->title);

    // Relacting the Line with the Background
    ScatterPlotSeries *s [] = {line};
    background->scatterPlotSeries = s;
	background->scatterPlotSeriesLength = 1;

    
    // Exporting:
    
    // Creating a image in the ram
    RGBABitmapImageReference *ram_image = CreateRGBABitmapImageReference();
    
    // Uploading all previous settings to the ram's image
    DrawScatterPlotFromSettings(ram_image, background, ((void *)0));
    size_t length;
	double *ram_png = ConvertToPNG(&length, ram_image->image);
	WriteToFile(ram_png, length, "final.png");
    DeleteImage(ram_image->image);

    return 0;
}
